## 메서드 정리

### 메서드 추출

- 어떤 코드를 그룹으로 묶어도 되겠다고 판단이 들 땐, 그 코드를 빼어서 목적을 잘 나타내는 직관적 이름의 메서드로 만들자.
- 방법
  - 목적에 부합하는 이름의 새 메서드를 생성하자. 이때 메서드명은 원리가 아니라 기능을 나타내는 이름이어야 한다.
    - 만약 더 이해하기 쉬운 이름으로 추출하지 않을 바에는 차라리 코드를 추출하지 말아야 한다.
  - 기존 메서드에서 빼낸 코드를 새로 생성한 메서드로 복사하자. 
    - `단축키 : cmd + option + m`
- 빼낸 코드에서 기존 메서드의 모든 지역변수 참조를 찾자. 그것들은 새로 생성한 메서드의 지역변수나 매개변수로 사용할 것이다.
  - `단축키 : cmd + options + p`
- 빼낸 코드 안에서만 사용되는 임시변수가 있는지 파악해서 있다면 그것들을 새로 생성한 메서드 안에 임시변수로 선언하자.
- 추출 코드에 의해 변경되는 지역변수가 있는지 파악하자. 만약 하나의 지역변수만 변경된다면 추출 코드를 메서드 호출처럼 취급할 수 있는지 알아내고
  그 결과를 관련된 변수에 대입할 수 있는지 알아내자. 이렇게 하기가 까다롭거나 둘 이상의 지역변수가 변경될 때는 메서드를 추출하기 위해 먼저 임시변수 분리 등의 기법을 적용해야 할 수도 있다. 임시변수를 제거하려면 임시 변수를 메서드
  호출로 전환 기법을 적용하면 된다. 
- 빼낸 코드에서 읽어들인 지역변수를 대상 메서드에 매개변수로 전달한다.
- 모든 지역변수 처리를 완료했으면 컴파일을 실행하자.
- 원본 메서드 안에 있는 빼낸 코드 부분을 새로 생성한 메서드 호출로 수정하자.
  - 대상 메서드로 임시변수를 옮겼으면 그 임시변수가 원본 코드 외부에 선언되어 있는지 검사해서, 그렇다면 대상 코드에서는 그 선언 부분을 삭제하자.
- 컴파일과 테스트를 실행하자.

#### 예제

- 지역변수를 다시 대입
~~~java
  void printOwing(){
    Enumeration e = orders.elements();
    double outstanding = 0.0;
    
    printBanner();
    
    while(e.hasMoreElements()){
        Order each = (Order) e.nextElement();
        outstanding += each.getAmount();
        }
    
    printDetails(outstanding);
}
~~~
  - 현재 지역변수 : outstanding
  - 외상액 계산 부분 메서드로 추출
~~~java
void printOwing(){
  double outstanding=getOutstanding();
  printBanner();
  printDetails(outstanding);
  }
        
double getOutstanding(){
  Enumeration e = orders.elements();
  double result = 0.0;
  while(e.hasMoreElements()){
    Order each = (Order) e.nextElement();
    result += each.getAmount();
  }
  return result
}
~~~
- 열거형 e 변수는 빼낸 코드에서만 사용되므로 그 변수를 새 메서드로 아예 옮겨도 된다.
- outstanding 변수는 기존 메서드에도 쓰이고 새 메서드에도 쓰이므로 빼낸 메서드에서 반환하게 해야한다.
- 빼낸 메서드를 컴파일하고 테스트 했으면, 언제나처럼 반환값의 이름을 변경하자.
- 간혹 임시변수가 너무 많으면 추출하기 어려워질 수 있다.
- 임시변수를 `메서드 호출로 전환 기법`을 실시해서 임시변수의 수를 줄이자.
- 어떤 방법을 사용해도 메서드 추출이 어렵다면 메서드를 `메서드 객체로 전환 기법`을 실시하자.
  - `필드 삽입 단축키 : cmd + option + F`

### 메서드 내용 직접 삽입
- 메서드 기능이 너무 단순해서 메서드명만 봐도 너무 뻔할 땐 그 메서드의 기능을 호출하는 메서드에 넣어버리고 그 메서드는 삭제하자.

#### 동기
- 리팩토링의 핵심은 의도한 기능을 한눈에 파악할 수 있는 직관적인 메서드명을 사용하는 것이다.
- 하지만 간혹 메서드에 모든 기능이 반역될 정도로 메서드 기능이 지나치게 단순할 때가 있다.
- 이럴 땐 **그 메서드를 없애야 한다**.

#### 방법
- 메서드가 제정의되어 있지 않은지 확인하자
  - 그 메서드가 하위클래스에 재정의되어 있다면 매서드 내용 직접 삽입을 실시하지 말자. 없어진 메서드를 재정의하는 일이 생겨선 안 되니 말이다.
- 그 메서드를 호출하는 부분을 모두 찾자.
- 각 호출 부분을 메서드 내용으로 교체하자
- 테스트를 실시하자
- 메서드 정의를 삭제하자.


### 임시변수 내용 직접 삽입
- 간단한 수식을 대입받는 임시변수로 인해 다른 리팩토링 기법 적용이 힘들 땐 그 임시변수를 참조하는 부분을 전부 수식으로 치환하자.
~~~java
double basePrice = anOrder.basePrice();
return (basePrice > 100);
~~~
~~~java
return (anOrder.basePrice() > 100);
~~~

#### 동기
- 임시변수 내용 직접 삽입만 수수하게 사용되는 경우는 오직 메서드 호출의 결과값이 임시변수에 대입될 때 뿐이다.
- 이러한 임시변수는 별다른 문제가 없으므로 내버려둬도 된다.
- 하지만 만일 임시변수가 메서드 추출 등 다른 리팩토링에 방해가 된다면 임시 변수 내용 직접 삽입을 적용해야 한다.

#### 방법
- 대입문의 우변에 문제가 없는지 확인하자.
- 문제가 없다면 임시변수를 final로 선언하고 컴파일하자.
- 임시변수를 참조하는 모든 부분을 찾아서 대입문 우변의 수식으로 바꾸자.
- 하나씩 수정을 마칠 때마다 컴파일과 테스트를 실시하자.
- 임시변수 선언과 대입문을 삭제하자.
- 컴파일과 테스트를 실시하자.

### 임시변수를 메서드 호출로 전환
- 수식의 결과를 저장하는 임시변수가 있을 땐, 그 수식을 빼내어 메서드로 만든 후 임시변수 참조 부분을 전부 수식으로 교체하자. 새로 만든 메서드는 다른 메서드에서 호출 가능하다.
~~~java
double basePrice = quantity * itemprice;
if(basePrice > 1000) return basePrice * 0.95;
return basePrice * 0.98;
~~~
~~~java
if(basePrice > 1000) return basePrice() * 0.95;
return basePrice() * 0.98;

double basePrice(){
    return quantity * itemprice;
        }
~~~
#### 동기
- 임시변수는 일시적이고 적용이 국소적 범위로 제한된다는 단점이 있다.
- 임시변수는 자신이 속한 메서드 안에서만 인식되므로, 그 임시변수에 접근하려다 보면 코드가 길어지기 마련이다.
- 임시변수를 메서드 호출로 전환은 대부분의 경우 메서드 추출을 적용하기 전에 반드시 적용해야 한다.


#### 방법
- 값이 한 번만 대입되는 임시변수를 찾다.
  - 값이 여러번 대입되는 임시변수가 있으면 임시변수 분리 기법 실시
- 그 임시변수를 final로 선언하자.
- 컴파일을 실시하자
- 대입문 우변을 빼내어 메서드로 만들자
- 컴파일과 테스트를 실시하자
- 임시변수를 대상으로 임시변수 내용 직접 삽입 기법을 실시하자.

### 직관적 임시변수 사용
- 사용된 수식이 복잡할 땐 수식의 결과나 수식의 일부분을 용도에 부합하는 직관적 이름의 임시변수에 대입하자.
#### 방법
- 임시변수를 final로 선언하고, 복잡한 수식에서 한 부분의 결과를 그 임시변수에 대입하자.
- 그 수식에서 한 부분의 결과를 그 임시변수의 값으로 교체하자
- 컴파일과 테스트를 실시하자
- 수식의 다른 부분을 대상으로 위의 과정을 반복 실시하자


