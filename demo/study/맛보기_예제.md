## 맛보기 예제

### 예제 요구사항

- 고객이 비디오를 빌릴 때, 대여한 비비도와 대여기간을 표시한다.
- 비디오의 종류와 대여기간을 토대로 대여료를 계산한다.
- 비디오의 종류는 일반물, 아동물, 최신물로 3종류이다. 
  - 단, 비디오의 종류는 자주 바뀐다.
- 최신물 비디오는 이틀 이상 대여하면 적립포인트 1만큼 더 준다. 
- 그외는 적립포인트는 기본 1이다.
- 대여료 계산 정책은 비디오 종류마다 다르다. 
  - 일반물 : 기본 = 1.5 , 대여기간 3일 초과 = 기본 + (대여기간 - 3) * 1.5
  - 최신물 : 기본 = 1 , 대여기간 2일 초과 = 2
  - 아동물 : 기본 = 2 , 대여기간 2일 초과 = (대여기간 - 2) * 1.5 + 기본

### 리팩토링을 해야하는 이유
- 매번 코드를 복사하여 붙여넣을 필요없게 코드를 유연하게 수정해야 함
- 요구사항이 변경되면 최소한의 코드 수정으로 요구 사항을 반영해야 함

### 간략한 과정
- 메서드 추출
  - 하나의 메서드는 하나의 기능만 가져야 한다.
  - 기존의 statement 메서드는 대여료 계산, 적립 포인트 계산 두 개의 기능을 수행하고 있다.
  - 따라서 대여료 계산과 적립 포인트 계산 기능을 두 개의 메서드로 분리할 필요가 있다.
- 메서드 변수 구분
  - 변경되지 않는 변수는 매개변수로, 변경되는 변수는 지역변수로 구분한다.
- 메서드 이동
  - 메서드가 자신이 속한 클래스 정보를 이용하지 않는다면 해당 메서드가 잘못된 객체에 위치한 것은 아닌지 살핀다.


### 나만의 리팩토링
- 나는 책의 리팩토링 과정을 최대한 따라가되, 중간중간 나만의 스타일로 리팩토링을 진행했다.
- 우선, 가장 처리하고 싶었던 부분은 switch 구문과 static 상수였다.

~~~java
public enum MovieType {
    CHILDRENS,
    NEW_RELEASE,
    REGULAR,
}
~~~

- 예제에선 따로 static 을 enum 타입으로 빼지 않았다. 하지만 나는 비디오의 종류가 더 늘어나거나 변경될 것을 고려하여
  enum 타입으로 뺐다. 그러면 Movie 클래스를 손 댈 필요도 없고, 만약 비디오의 종류가 많아져도 Movie 클래스의 코드가 더러워질 일도 없을 것이다.

~~~java
public interface PriceInterface {
    MovieType getPriceCode();
    double getCharge(int daysRented);
    int getFrequentRenterPoints(int daysRented);
}
~~~
- 또한 추상 클래스로 만들었던 Price 클래스를 interface 로 만들면 어떨까 생각이 들었다.
- 영한 님의 강의를 들을 때, 요즘은 추상 클래스가 아닌 인터페이스를 사용하는 추세라는 말을 들었기 때문이다.
>> 그럼 지금 예제의 상황에선 추상 클래스가 더 적합할까 아니면 인터페이스가 더 적합할까?
- 개인적으로 이 상황에서는 추상클래스가 더 편할 것 같다. 특히 적립 포인트를 계산하는 메서드를 구현할 때, 최신물의 경우에만
  포인트를 2만큼 적립하기 때문에, 부모 클래스를 오버라이딩 해서 쓰는 게 더 편하다. 인터페이스로 구현했다면
  인터페이스는 메서드 구현이 불가능하기 때문에 모든 클래스에 포인트 적립 메서드를 작성해야할 것이다. 그럼 불필요한 코드 중복이 발생하지 않을까?
- 추상 메서드를 사용하는 경우 vs 인터페이스를 사용하는 경우
  - https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-vs-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0
- 위 게시물을 읽어보고 상황에 따라 추상메서드 또는 인터페이스를 적절하게 사용해야겠다 ^^..!

~~~java
public class PriceConfig {

    public Price getPricePolicy(MovieType type){
        if(type == MovieType.CHILDRENS) return new ChildrenPrice();
        if(type == MovieType.REGULAR) return new RegularPrice();
        if(type == MovieType.NEW_RELEASE) return new NewReleasePrice();
        throw new IllegalArgumentException("대여료 가격 정책을 찾지 못했습니다.");
    }
}
~~~
- 그리고 타입에 따라 가격 정책의 객체가 반환되는 함수가 Movie 클래스 안에 있어서 거슬렸다.
- 만약 비디오의 종류가 늘어난다면 Movie 클래스를 계속 수정해야하는 상황이 온다. 그러다 종류가 몇 십개를 넘어가면
  Movie의 비즈니스 메서드와 섞여서 코드가 어지럽게 될 것 같았다. 
- 그래서 PriceConfig 라는 클래스를 만들어 비디오 종류에 알맞는 가격 정책 객체를 반환하는 메서드를 분리했다. 
- 이렇게 분리하면 나중에 새로운 가격 정책을 등록할 때, Config 만 수정하면 돼서 편리할 것 같다. 
- 하지만 ... 내가 또 거슬리는 부분은 위처럼 Config를 만들었을 때, Config 자체가 구체 클래스이기 때문에 DIP 원칙에 위배된다는 점이다.
- 그럼 또 Config 자체를 인터페이스로 만들자니 너무 과한 분리인 것 같고 .. 잘 모르겠다 ^^ .. 어렵다 ... ! SOLID 지켜가며 코딩하기 참 쉽지 않다 ㅎㅎ